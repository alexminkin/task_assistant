1. Структура и модулярность  
   • «Ядро» приложения лежит в директории `app/`.  
   • Для крупных областей логики (CustomConfig, Estate, User и т. д.) мы используем пакет `nwidart/laravel-modules`, чтобы держать контроллеры, модели, миграции, роуты и сервисы каждого модуля в своём каталоге.  

2. Обработка HTTP-запросов  
   • Все API-маршруты описаны в `routes/api.php` (в корне и внутри модулей).  
   • Запросы проходят через глобальные middleware (аутентификация, CORS и т.п.) и модульные (права доступа, throttling, кастомная валидация).  
   • Данные приходят в контроллеры, которые делегируют валидацию в Form Request, бизнес-логику — в сервисы, а ответы формируют через API Resources.  

3. Сервисный слой и репозитории  
   • В папках `Services` и `Modules/.../Services` реализована «чистая» бизнес-логика.  
   • `Repositories` инкапсулируют взаимодействие с базой (Eloquent, Doctrine или PDO).  
   • Такой подход облегчает юнит-тестирование и повторное использование компонентов.  

4. Конфигурация и окружение  
   • Переменные окружения хранится в `.env` (Credentials, URL, ключи API).  
   • Файлы в `config/` настраивают сторонние библиотеки и параметры приложения.  
   • На продакшене и в CI мы кэшируем конфигурацию и маршруты (`php artisan config:cache`, `route:cache`).  

5. Сборка и деплой  
   • Зависимости PHP управляются через Composer.  
   • Сборка Docker-образов и пуш в приватный регистр происходит в GitLab CI.  
   • Деплой на сервера осуществляется через Ansible-плейбуки, которые подтягивают нужную версию кода и выполняют миграции и очистку.  

6. Артисан-команды и CRON  
   • В `app/Console/Kernel.php` описаны задачи планировщика (`schedule`).  
   • Кастомные команды Artisan (`php artisan your:command`) реализуют периодические операции (очистка, сбор статистики и т.д.).  

7. События и очереди  
   • Для тяжёлых или асинхронных задач (отправка писем, генерация отчётов) используются события (`Events`/`Listeners`) и очередь (Redis, database).  